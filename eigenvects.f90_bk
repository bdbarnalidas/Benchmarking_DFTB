# 1 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"
# 1 "<built-in>"
# 1 "<command-line>"


# 1 "/usr/include/stdc-predef.h" 1 3 4

# 17 "/usr/include/stdc-predef.h" 3 4











































# 2 "<command-line>" 2
# 1 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"
!!* Module to wrap around the process of converting from a Hamiltonian and
!!* overlap in sparse form into eigenvectors
module Eigenvects

# 1 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/../includes/assert.h" 1
!! -*- f90 -*-
!! vim:syntax=fortran:
!!
!! Provides C-style assertions for Fortran
!! (compile the source with 0>=1 to use it)
!!









!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Debug turned on
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 35 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/../includes/assert.h"









!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 5 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90" 2

# 1 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/../includes/allocate.h" 1
!! -*- f90 -*-
!! Provides trapped allocate and deallocate for Fortran
!! (compile the source with 0>=2 to use the verbose version)
!!

use allocation




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Low-level macros.
!! Do NOT use them, use the 0-level specific ones instead
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



















# 43 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/../includes/allocate.h"
































!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Debug turned on and its level is high enough
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 115 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/../includes/allocate.h"



























!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Macros for initialization and allocation in one step
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!









!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 6 "/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90" 2
!#include "magma.h"
!#include "magma_lapack.h"
  use magma
  use accuracy
  use eigensolver
  use sparse2Dense
  use message
  use CommonTypes, only : TOrbitals
  use angmomentum
  implicit none

  public :: diagonalize
  private

  interface diagonalize
    module procedure realH
    module procedure cmplxH
    module procedure cmplx2Cmpnt
    module procedure cmplx2CmpntKpts
  end interface

contains

  !!* Diagonalizes a sparse represented Hamiltonian and overlap to give
  !!* the eigenvectors and values, as well as often the Cholesky factorized
  !!* overlap matrix (due to a side effect of lapack)
  !!* @param HSqrReal Large square matrix for the resulting eigenvectors
  !!* @param SSqrReal Large square matrix for the overlap workspace, often
  !!* overwritten with the  Cholesky factorized form.
  !!* @param eigen The eigenvalues of the matrices
  !!* @param ham The sparse represented Hamiltonian in real space
  !!* @param over The sparse represented overlap matrix in real space
  !!* @param iNeighbor List of atomic neighbors for each central cell atom
  !!* @param nNeighbor Number of atomic neighbors for each central cell atom
  !!* @param iAtomStart Indexing array for the large square matrices to relate
  !!* atom number to position in the matrix
  !!* @param img2CentCell Array to relate image atoms outside the central cell
  !!* to their real counterpart inside the cell
  !!* @param iSolver Choice of eigensolver, 4 lapack dense solvers currently
  !!* supported
  !!* @param jobz type of eigen-problem, either 'V'/'v' vectors or 'N'/'n'
  !!* eigenvalues only
  subroutine realH(HSqrReal, SSqrReal, eigen, ham, over, iNeighbor, nNeighbor, &
      &iAtomStart, iPair, img2CentCell, iSolver, jobz)
    real(dp), intent(out) :: HSqrReal(:,:)
    real(dp), intent(out) :: SSqrReal(:,:)
    real(dp), intent(out) :: eigen(:)
    real(dp), intent(in)  :: ham(:)
    real(dp), intent(in)  :: over(:)
    integer,  intent(in)  :: iNeighbor(0:,:)
    integer,  intent(in)  :: nNeighbor(:)
    integer,  intent(in)  :: iAtomStart(:)
    integer,  intent(in)  :: iPair(0:,:)
    integer,  intent(in)  :: img2CentCell(:)
    integer,  intent(in)  :: iSolver
    character, intent(in) :: jobz

    integer :: nOrb








    call unpackHS(HSqrReal,ham,iNeighbor,nNeighbor,iAtomStart,iPair, &
        &img2CentCell)
    call unpackHS(SSqrReal,over,iNeighbor,nNeighbor,iAtomStart,iPair, &
        & img2CentCell)

    select case(iSolver)
!    case(1)
!      call magma_hegv(HSqrReal,SSqrReal,eigen,'L',jobz)
!    case(2)
!      call magma_hegvd(HSqrReal,SSqrReal,eigen,'L',jobz)
!    case(3)

    case(1)
      call hegv(HSqrReal,SSqrReal,eigen,'L',jobz)
    case(2)
      call hegvd(HSqrReal,SSqrReal,eigen,'L',jobz)
    case(3)
      ! use subspace for all eigenstates
      nOrb = size(eigen)
      call gvr(HSqrReal,SSqrReal,eigen,'L',jobz,ilIn=1,iuIn=nOrb)
    case default
      call error('Unknown eigensolver')
    end select

  end subroutine realH



  !!* Diagonalizes a sparse represented Hamiltonian and overlap to give
  !!* the eigenvectors and values, as well as often the Cholesky factorized
  !!* overlap matrix (due to a side effect of lapack)
  !!* @param HSqrCplx Large square matrix for the resulting eigenvectors
  !!* @param SSqrCplx Large square matrix for the overlap workspace, often
  !!* overwritten with the  Cholesky factorized form.
  !!* @param eigen The eigenvalues of the matrices
  !!* @param ham The sparse represented Hamiltonian in real space
  !!* @param over The sparse represented overlap matrix in real space
  !!* @param kpoint The k-point to evaluate the phase factors for
  !!* @param iNeighbor List of atomic neighbors for each central cell atom
  !!* @param nNeighbor Number of atomic neighbors for each central cell atom
  !!* @param iCellVec Index of the cell translation vector for each atom.
  !!& @param cellVec Relative coordinates of the cell translation vectors.
  !!* @param iAtomStart Indexing array for the large square matrices to relate
  !!* atom number to position in the matrix
  !!* @param img2CentCell Array to relate image atoms outside the central cell
  !!* to their real counterpart inside the cell
  !!* @param iSolver Choice of eigensolver, 4 lapack dense solvers currently
  !!* supported
  !!* @param jobz type of eigen-problem, either 'V'/'v' vectors or 'N'/'n'
  !!* eigenvalues only
  subroutine cmplxH(HSqrCplx, SSqrCplx, eigen, ham, over, kpoint, iNeighbor, &
      &nNeighbor, iCellVec, cellVec, iAtomStart, iPair, img2CentCell, &
      &iSolver, jobz)
    complex(dp), intent(out) :: HSqrCplx(:,:)
    complex(dp), intent(out) :: SSqrCplx(:,:)
    real(dp), intent(out)    :: eigen(:)
    real(dp), intent(in)     :: ham(:)
    real(dp), intent(in)     :: over(:)
    real(dp), intent(in)     :: kpoint(3)
    integer,  intent(in)     :: iNeighbor(0:,:)
    integer,  intent(in)     :: nNeighbor(:)
    integer,  intent(in)     :: iCellVec(:)
    real(dp), intent(in)     :: cellVec(:,:)
    integer,  intent(in)     :: iAtomStart(:)
    integer,  intent(in)     :: iPair(0:,:)
    integer,  intent(in)     :: img2CentCell(:)
    integer,  intent(in)     :: iSolver
    character, intent(in)    :: jobz

    integer :: nOrb







    call unpackHS(HSqrCplx, ham, kPoint, iNeighbor, nNeighbor, iCellVec, &
        &cellVec, iAtomStart, iPair, img2CentCell)
    call unpackHS(SSqrCplx, over, kPoint, iNeighbor, nNeighbor, iCellVec, &
        &cellVec, iAtomStart, iPair, img2CentCell)

    select case(iSolver)
    case(1)
      call hegv(HSqrCplx,SSqrCplx,eigen,'L',jobz)
    case(2)
      call hegvd(HSqrCplx,SSqrCplx,eigen,'L',jobz)
    case(3)
      ! use subspace for all eigenstates
      nOrb = size(eigen)
      call gvr(HSqrCplx,SSqrCplx,eigen,'L',jobz,ilIn=1,iuIn=nOrb)
    case default
      call error('Unknown eigensolver')
    end select

  end subroutine cmplxH

  !!* Diagonalizes a sparse represented Hamiltonian and overlap to give
  !!* the eigenvectors and values, as well as often the Cholesky factorized
  !!* overlap matrix (due to a side effect of lapack)
  !!* @param HSqrCplx Large square matrix for the resulting eigenvectors
  !!* @param SSqrCplx Large square matrix for the overlap workspace, often
  !!* overwritten with the  Cholesky factorized form.
  !!* @param eigen The eigenvalues of the matrices
  !!* @param ham The sparse represented Hamiltonian in real space
  !!* @param over The sparse represented overlap matrix in real space
  !!* @param iNeighbor List of atomic neighbors for each central cell atom
  !!* @param nNeighbor Number of atomic neighbors for each central cell atom
  !!* @param iAtomStart Indexing array for the large square matrices to relate
  !!* atom number to position in the matrix
  !!* @param img2CentCell Array to relate image atoms outside the central cell
  !!* to their real counterpart inside the cell
  !!* @param iSolver Choice of eigensolver, 4 lapack dense solvers currently
  !!* supported
  !!* @param jobz type of eigen-problem, either 'V'/'v' vectors or 'N'/'n'
  !!* eigenvalues only
  !!* @param xi optional spin orbit constants for each shell of each species
  !!* @param orb Contains information about the atomic orbitals in the system
  !!* @param species optional atomic species
  !!* @param iHam optional coefficients for imaginary part of the Hamiltonian
  subroutine cmplx2Cmpnt(HSqrCplx, SSqrCplx, eigen, ham, over, iNeighbor, &
      & nNeighbor, iAtomStart, iPair, img2CentCell, iSolver, jobz,xi,orb, &
      & species, iHam)

    complex(dp), intent(out) :: HSqrCplx(:,:)
    complex(dp), intent(out) :: SSqrCplx(:,:)
    real(dp), intent(out)    :: eigen(:)
    real(dp), intent(in)     :: ham(:,:)
    real(dp), intent(in)     :: over(:)
    integer,  intent(in)     :: iNeighbor(0:,:)
    integer,  intent(in)     :: nNeighbor(:)
    integer,  intent(in)     :: iAtomStart(:)
    integer,  intent(in)     :: iPair(0:,:)
    integer,  intent(in)     :: img2CentCell(:)
    integer,  intent(in)     :: iSolver
    character, intent(in)    :: jobz
    real(dp), intent(in), optional        :: xi(:,:)
    type(TOrbitals), intent(in), optional :: orb
    integer, intent(in), optional         :: species(:)
    real(dp), intent(in), optional        :: iHam(:,:)

    integer :: nOrb, nSpin, ii, jj, kk
    real(dp), allocatable :: work(:,:)
    logical :: tSpinOrb
    integer :: nAtom, nSpecies
    complex(dp), allocatable :: AtomZ(:,:,:)
    complex(dp), allocatable :: AtomPlus(:,:,:)
    complex(dp), allocatable :: Lz(:,:)
    complex(dp), allocatable :: Lplus(:,:)


     ! for the moment








    nAtom = size(nNeighbor)
    nSpin = size(ham,dim=2)
    nOrb = size(eigen)

    tSpinOrb = present(xi)



    nOrb = nOrb / 2
if (.not. allocated(work)) then;    allocate(work  (nOrb,nOrb), stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonben&
&nie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 233 
&, 241, ioerr, 1);  endif
# 234 
    ! in the future

    SSqrCplx(:,:) = 0.0_dp
    HSqrCplx(:,:) = 0.0_dp

    work(:,:) = 0.0_dp
    call unpackHS(work,over,iNeighbor,nNeighbor,iAtomStart,iPair, &
        &img2CentCell)
    SSqrCplx(1:nOrb,1:nOrb) = work(1:nOrb,1:nOrb)
    SSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = work(1:nOrb,1:nOrb)

    ! 1 0 charge part
    ! 0 1
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,1),iNeighbor,nNeighbor,iAtomStart,iPair, &
        &img2CentCell)
    HSqrCplx(1:nOrb,1:nOrb) = 0.5_dp*work(1:nOrb,1:nOrb)
    HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = 0.5_dp*work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,1),iNeighbor,nNeighbor,iAtomStart,iPair, &
          &img2CentCell)
      HSqrCplx(1:nOrb,1:nOrb) = HSqrCplx(1:nOrb,1:nOrb) &
          & + 0.5_dp*cmplx(0,1,dp)*work(1:nOrb,1:nOrb)
      HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = &
          & HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) &
          & + 0.5_dp*cmplx(0,1,dp)*work(1:nOrb,1:nOrb)
    end if

    ! 0 1 x part
    ! 1 0
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,2),iNeighbor,nNeighbor,iAtomStart,iPair, &
        &img2CentCell)
    call blockSymmetrizeHS(work,iAtomStart)
    HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
        & + 0.5_dp * work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,2),iNeighbor,nNeighbor,iAtomStart,iPair, &
          &img2CentCell)
      call blockAntiSymmetrizeHS(work,iAtomStart)
      HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
          & + 0.5_dp *cmplx(0,1,dp)* work(1:nOrb,1:nOrb)
    end if

    ! 0 -i y part
    ! i  0
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,3),iNeighbor,nNeighbor,iAtomStart,iPair, &
        &img2CentCell)
    call blockSymmetrizeHS(work,iAtomStart)
    HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
        & + cmplx(0.0,0.5,dp) * work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,3),iNeighbor,nNeighbor,iAtomStart,iPair, &
          &img2CentCell)
      call blockAntiSymmetrizeHS(work,iAtomStart)
      HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
          & - 0.5_dp * work(1:nOrb,1:nOrb)
    end if

    ! 1  0 z part
    ! 0 -1
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,4),iNeighbor,nNeighbor,iAtomStart,iPair, &
        &img2CentCell)
    HSqrCplx(1:nOrb,1:nOrb) = HSqrCplx(1:nOrb,1:nOrb) &
        & + 0.5_dp * work(1:nOrb,1:nOrb)
    HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = &
        & HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) &
        & - 0.5_dp * work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,4),iNeighbor,nNeighbor,iAtomStart,iPair, &
          &img2CentCell)
      HSqrCplx(1:nOrb,1:nOrb) = HSqrCplx(1:nOrb,1:nOrb) &
          & + 0.5_dp * cmplx(0,1,dp) * work(1:nOrb,1:nOrb)
      HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = &
          & HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) &
          & - 0.5_dp * cmplx(0,1,dp) * work(1:nOrb,1:nOrb)
    end if

    if (tSpinOrb) then
      nSpecies = maxval(species(1:nAtom))
if (.not. allocated(AtomZ)) then;    allocate(AtomZ  (orb%mOrb,orb%mOrb,nSpecies), stat=ioerr);    if (ioerr /= 0) call allocateEr&
# 320 
&ror("/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90", 328, ioerr, 1);  endif
# 321 
      AtomZ = 0.0_dp
if (.not. allocated(AtomPlus)) then;    allocate(AtomPlus  (orb%mOrb,orb%mOrb,nSpecies), stat=ioerr);    if (ioerr /= 0) call allo&
# 322 
&cateError("/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90", 330, ioerr, 1);  endif
# 323 
      AtomPlus = 0.0_dp
if (.not. allocated(Lz)) then;    allocate(Lz  (orb%mOrb,orb%mOrb), stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simo&
&nbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 324 
&, 332, ioerr, 1);  endif
# 325 
if (.not. allocated(Lplus)) then;    allocate(Lplus  (orb%mOrb,orb%mOrb), stat=ioerr);    if (ioerr /= 0) call allocateError("/hom&
&e/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 325 
&, 333, ioerr, 1);  endif
# 326 
      do ii = 1, nSpecies
        do jj = 1, orb%nShell(ii)
          Lz = 0.0_dp
          Lplus = 0.0_dp
          kk = orb%angShell(jj,ii)
          call loperators(Lplus(1:2*kk+1,1:2*kk+1),Lz(1:2*kk+1,1:2*kk+1),kk)
          AtomZ(orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1, &
              & orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1,ii) &
              & = 0.5_dp*xi(jj,ii)*Lz(1:2*kk+1,1:2*kk+1)
          AtomPlus(orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1, &
              & orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1,ii) &
              & = 0.5_dp*xi(jj,ii)*Lplus(1:2*kk+1,1:2*kk+1)
        end do
      end do
if (allocated(Lplus)) then;    deallocate(Lplus, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_w&
&rapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 340 
&,348,ioerr, 2);  endif
# 341 
if (allocated(Lz)) then;    deallocate(Lz, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_wrapper&
&/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 341 
&,349,ioerr, 2);  endif
# 342 
      do ii = 1, nAtom
        jj = species(ii)
        HSqrCplx(iAtomStart(ii):iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) = &
            & HSqrCplx(iAtomStart(ii):iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) &
            & + AtomZ(1:orb%nOrbSpecie(jj),1:orb%nOrbSpecie(jj),jj)
        HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1) = &
            & HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1) &
            & - AtomZ(1:orb%nOrbSpecie(jj),1:orb%nOrbSpecie(jj),jj)
        HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) = &
            & HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) &
            & + AtomPlus(1:orb%nOrbSpecie(jj),1:orb%nOrbSpecie(jj),jj)
      end do
if (allocated(AtomZ)) then;    deallocate(AtomZ, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_w&
&rapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 360 
&,368,ioerr, 2);  endif
# 361 
if (allocated(AtomPlus)) then;    deallocate(AtomPlus, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/&
&dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 361 
&,369,ioerr, 2);  endif
# 362 
    end if

    select case(iSolver)
    case(1)
      call hegv(HSqrCplx,SSqrCplx,eigen,'L',jobz)
    case(2)
      call hegvd(HSqrCplx,SSqrCplx,eigen,'L',jobz)
    case(3)
      call gvr(HSqrCplx,SSqrCplx,eigen,'L',jobz,ilIn=1,iuIn=2*nOrb)
    case default
      call error('Unknown eigensolver')
    end select

if (allocated(work)) then;    deallocate(work, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_wra&
&pper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 375 
&,383,ioerr, 2);  endif
# 376 

  end subroutine cmplx2Cmpnt

  !!* Diagonalizes a sparse represented Hamiltonian and overlap to give
  !!* the eigenvectors and values, as well as often the Cholesky factorized
  !!* overlap matrix (due to a side effect of lapack)
  !!* @param HSqrCplx Large square matrix for the resulting eigenvectors
  !!* @param SSqrCplx Large square matrix for the overlap workspace, often
  !!* overwritten with the  Cholesky factorized form.
  !!* @param eigen The eigenvalues of the matrices
  !!* @param ham The sparse represented Hamiltonian in real space
  !!* @param over The sparse represented overlap matrix in real space
  !!* @param iNeighbor List of atomic neighbors for each central cell atom
  !!* @param nNeighbor Number of atomic neighbors for each central cell atom
  !!* @param iAtomStart Indexing array for the large square matrices to relate
  !!* atom number to position in the matrix
  !!* @param img2CentCell Array to relate image atoms outside the central cell
  !!* to their real counterpart inside the cell
  !!* @param iSolver Choice of eigensolver, 4 lapack dense solvers currently
  !!* supported
  !!* @param jobz type of eigen-problem, either 'V'/'v' vectors or 'N'/'n'
  !!* eigenvalues only
  !!* @param xi optional spin orbit constants for each shell of each species
  !!* @param orb Contains information about the atomic orbitals in the system
  !!* @param species optional atomic species
  !!* @param iHam optional coefficients for imaginary part of the Hamiltonian
  subroutine cmplx2CmpntKpts(HSqrCplx, SSqrCplx, eigen, ham, over, kpoint, &
      & iNeighbor, nNeighbor, iCellVec, cellVec, iAtomStart, iPair, &
      & img2CentCell, iSolver, jobz,xi,orb, species, iHam)
    complex(dp), intent(out) :: HSqrCplx(:,:)
    complex(dp), intent(out) :: SSqrCplx(:,:)
    real(dp), intent(out)    :: eigen(:)
    real(dp), intent(in)     :: ham(:,:)
    real(dp), intent(in)     :: over(:)
    real(dp), intent(in)     :: kpoint(3)
    integer,  intent(in)     :: iNeighbor(0:,:)
    integer,  intent(in)     :: nNeighbor(:)
    integer,  intent(in)     :: iCellVec(:)
    real(dp), intent(in)     :: cellVec(:,:)
    integer,  intent(in)     :: iAtomStart(:)
    integer,  intent(in)     :: iPair(0:,:)
    integer,  intent(in)     :: img2CentCell(:)
    integer,  intent(in)     :: iSolver
    character, intent(in)    :: jobz
    real(dp), intent(in), optional        :: xi(:,:)
    type(TOrbitals), intent(in), optional :: orb
    integer, intent(in), optional         :: species(:)
    real(dp), intent(in), optional        :: iHam(:,:)

    integer :: nOrb, nSpin, ii, jj, kk
    complex(dp), allocatable :: work(:,:)
    logical :: tSpinOrb
    integer :: nAtom, nSpecies
    complex(dp), allocatable :: AtomZ(:,:,:)
    complex(dp), allocatable :: AtomPlus(:,:,:)
    complex(dp), allocatable :: Lz(:,:)
    complex(dp), allocatable :: Lplus(:,:)


     ! for the moment








    nAtom = size(nNeighbor)
    nSpin = size(ham,dim=2)
    nOrb = size(eigen)

    tSpinOrb = present(xi)



    nOrb = nOrb / 2
if (.not. allocated(work)) then;    allocate(work  (nOrb,nOrb), stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonben&
&nie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 453 
&, 461, ioerr, 1);  endif
# 454 
    ! in the future

    SSqrCplx(:,:) = 0.0_dp
    HSqrCplx(:,:) = 0.0_dp

    work(:,:) = 0.0_dp
    call unpackHS(work,over,kPoint, iNeighbor,nNeighbor,iCellVec, &
        & cellVec, iAtomStart,iPair, img2CentCell)
    SSqrCplx(1:nOrb,1:nOrb) = work(1:nOrb,1:nOrb)
    SSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = work(1:nOrb,1:nOrb)

    ! 1 0 charge part
    ! 0 1
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,1),kPoint,iNeighbor,nNeighbor,iCellVec, &
        & cellVec,iAtomStart,iPair, img2CentCell)
    HSqrCplx(1:nOrb,1:nOrb) = 0.5_dp*work(1:nOrb,1:nOrb)
    HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = 0.5_dp*work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,1),kPoint,iNeighbor,nNeighbor,iCellVec, &
        & cellVec,iAtomStart,iPair, img2CentCell)
      HSqrCplx(1:nOrb,1:nOrb) = HSqrCplx(1:nOrb,1:nOrb) &
          & + 0.5_dp*cmplx(0,1,dp)*work(1:nOrb,1:nOrb)
      HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = &
          & HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) &
          & + 0.5_dp*cmplx(0,1,dp)*work(1:nOrb,1:nOrb)
    end if

    ! 0 1 x part
    ! 1 0
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,2),kPoint,iNeighbor,nNeighbor,iCellVec, &
        & cellVec,iAtomStart,iPair, img2CentCell)
    do ii = 1, nOrb
      work(ii,ii+1:) = conjg(work(ii+1:,ii))
    end do

    HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
        & + 0.5_dp * work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,2),kPoint,iNeighbor,nNeighbor,iCellVec, &
         & cellVec,iAtomStart,iPair, img2CentCell)
      do ii = 1, nOrb
        work(ii,ii+1:) = -conjg(work(ii+1:,ii))
      end do
      HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
          & + 0.5_dp *cmplx(0,1,dp)* work(1:nOrb,1:nOrb)
    end if


    ! 0 -i y part
    ! i  0
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,3),kPoint,iNeighbor,nNeighbor,iCellVec, &
        & cellVec,iAtomStart,iPair, img2CentCell)
    do ii = 1, nOrb
      work(ii,ii+1:) = conjg(work(ii+1:,ii))
    end do

    HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
        & + cmplx(0.0,0.5,dp) * work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,3),kPoint,iNeighbor,nNeighbor,iCellVec, &
          & cellVec,iAtomStart,iPair, img2CentCell)
      do ii = 1, nOrb
        work(ii,ii+1:) = -conjg(work(ii+1:,ii))
      end do
      do ii = 1, nOrb
        work(ii+1:,ii) = -conjg(work(ii,ii+1:))
      end do

      HSqrCplx(nOrb+1:2*nOrb,1:nOrb) = HSqrCplx(nOrb+1:2*nOrb,1:nOrb) &
          & - 0.5_dp * work(1:nOrb,1:nOrb)
    end if


    ! 1  0 z part
    ! 0 -1
    work(:,:) = 0.0_dp
    call unpackHS(work,ham(:,4),kPoint,iNeighbor,nNeighbor,iCellVec, &
        & cellVec,iAtomStart,iPair, img2CentCell)
    HSqrCplx(1:nOrb,1:nOrb) = HSqrCplx(1:nOrb,1:nOrb) &
        & + 0.5_dp * work(1:nOrb,1:nOrb)
    HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = &
        & HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) &
        & - 0.5_dp * work(1:nOrb,1:nOrb)
    if (present(iHam)) then
      work(:,:) = 0.0_dp
      call unpackHS(work,iHam(:,4),kPoint,iNeighbor,nNeighbor,iCellVec, &
        & cellVec,iAtomStart,iPair, img2CentCell)
      HSqrCplx(1:nOrb,1:nOrb) = HSqrCplx(1:nOrb,1:nOrb) &
          & + 0.5_dp * cmplx(0,1,dp) * work(1:nOrb,1:nOrb)
      HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) = &
          & HSqrCplx(nOrb+1:2*nOrb,nOrb+1:2*nOrb) &
          & - 0.5_dp * cmplx(0,1,dp) * work(1:nOrb,1:nOrb)
    end if

    if (tSpinOrb) then
      nSpecies = maxval(species(1:nAtom))
if (.not. allocated(AtomZ)) then;    allocate(AtomZ  (orb%mOrb,orb%mOrb,nSpecies), stat=ioerr);    if (ioerr /= 0) call allocateEr&
# 556 
&ror("/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90", 564, ioerr, 1);  endif
# 557 
      AtomZ = 0.0_dp
if (.not. allocated(AtomPlus)) then;    allocate(AtomPlus  (orb%mOrb,orb%mOrb,nSpecies), stat=ioerr);    if (ioerr /= 0) call allo&
# 558 
&cateError("/home/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90", 566, ioerr, 1);  endif
# 559 
      AtomPlus = 0.0_dp
if (.not. allocated(Lz)) then;    allocate(Lz  (orb%mOrb,orb%mOrb), stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simo&
&nbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 560 
&, 568, ioerr, 1);  endif
# 561 
if (.not. allocated(Lplus)) then;    allocate(Lplus  (orb%mOrb,orb%mOrb), stat=ioerr);    if (ioerr /= 0) call allocateError("/hom&
&e/simonbennie/gits/dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 561 
&, 569, ioerr, 1);  endif
# 562 
      do ii = 1, nSpecies
        do jj = 1, orb%nShell(ii)
          Lz = 0.0_dp
          Lplus = 0.0_dp
          kk = orb%angShell(jj,ii)
          call loperators(Lplus(1:2*kk+1,1:2*kk+1),Lz(1:2*kk+1,1:2*kk+1),kk)
          AtomZ(orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1, &
              & orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1,ii) &
              & = 0.5_dp*xi(jj,ii)*Lz(1:2*kk+1,1:2*kk+1)
          AtomPlus(orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1, &
              & orb%posShell(jj,ii):orb%posShell(jj+1,ii)-1,ii) &
              & = 0.5_dp*xi(jj,ii)*Lplus(1:2*kk+1,1:2*kk+1)
        end do
      end do
if (allocated(Lplus)) then;    deallocate(Lplus, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_w&
&rapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 576 
&,584,ioerr, 2);  endif
# 577 
if (allocated(Lz)) then;    deallocate(Lz, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_wrapper&
&/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 577 
&,585,ioerr, 2);  endif
# 578 
      do ii = 1, nAtom
        jj = species(ii)
        HSqrCplx(iAtomStart(ii):iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) = &
            & HSqrCplx(iAtomStart(ii):iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) &
            & + AtomZ(1:orb%nOrbSpecie(jj),1:orb%nOrbSpecie(jj),jj)
        HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1) = &
            & HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1) &
            & - AtomZ(1:orb%nOrbSpecie(jj),1:orb%nOrbSpecie(jj),jj)
        HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) = &
            & HSqrCplx(nOrb+iAtomStart(ii):nOrb+iAtomStart(ii+1)-1, &
            & iAtomStart(ii):iAtomStart(ii+1)-1) &
            & + AtomPlus(1:orb%nOrbSpecie(jj),1:orb%nOrbSpecie(jj),jj)
      end do
if (allocated(AtomZ)) then;    deallocate(AtomZ, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_w&
&rapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 596 
&,604,ioerr, 2);  endif
# 597 
if (allocated(AtomPlus)) then;    deallocate(AtomPlus, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/&
&dftb_wrapper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 597 
&,605,ioerr, 2);  endif
# 598 
    end if

    select case(iSolver)
    case(1)
      call hegv(HSqrCplx,SSqrCplx,eigen,'L',jobz)
    case(2)
      call hegvd(HSqrCplx,SSqrCplx,eigen,'L',jobz)
    case(3)
      call gvr(HSqrCplx,SSqrCplx,eigen,'L',jobz,ilIn=1,iuIn=2*nOrb)
    case default
      call error('Unknown eigensolver')
    end select

if (allocated(work)) then;    deallocate(work, stat=ioerr);    if (ioerr /= 0) call allocateError("/home/simonbennie/gits/dftb_wra&
&pper/mike/dftb+_1.2.2_src/prg_dftb/eigenvects.F90"&
# 611 
&,619,ioerr, 2);  endif
# 612 

  end subroutine cmplx2CmpntKpts

end module Eigenvects
